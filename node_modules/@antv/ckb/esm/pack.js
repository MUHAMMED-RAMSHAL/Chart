import { I18N, translateMapping } from './i18n';
import { base } from './base';
/**
 * A cheap way to get a copy of base.
 */
function newBase() {
    return JSON.parse(JSON.stringify(base));
}
/**
 * Get a CKB object.
 *
 * @param lang - Language of the CKB.
 * @param completed - True if only charts with fully completed knowledge should be included. Default is false.
 *
 * @public
 */
export function CKBJson(lang, completed) {
    if (lang === void 0) { lang = 'en-US'; }
    if (completed === void 0) { completed = false; }
    var base = newBase();
    var CKB = {};
    var ids = Object.keys(base);
    // Filtering charts: completed or full.
    ids.forEach(function (chartID) {
        var chartKnowledge = base[chartID];
        var valid = true;
        if (completed) {
            var keys = Object.keys(chartKnowledge);
            for (var i = 0; i < keys.length; i += 1) {
                var key = keys[i];
                var value = chartKnowledge[key];
                if (key !== 'alias' && key !== 'channel' && typeof value !== 'boolean') {
                    if ((Array.isArray(value) && value.length === 0) || !value) {
                        valid = false;
                        break;
                    }
                }
            }
        }
        if (valid) {
            CKB[chartID] = chartKnowledge;
        }
    });
    // Translate.
    var CKBJ = {};
    if (lang && lang !== 'en-US') {
        var translator_1 = I18N(lang);
        var chartIDs = Object.keys(CKB);
        if (translator_1) {
            chartIDs.forEach(function (chartID) {
                CKBJ[chartID] = {};
                CKBJ[chartID].id = chartID;
                CKBJ[chartID].name = translator_1.chartTypes[chartID].name;
                CKBJ[chartID].alias = translator_1.chartTypes[chartID].alias;
                CKBJ[chartID].def = translator_1.chartTypes[chartID].def;
                CKBJ[chartID].family = CKB[chartID].family.map(function (e) { return translator_1.concepts.family[e]; });
                CKBJ[chartID].purpose = CKB[chartID].purpose.map(function (e) { return translator_1.concepts.purpose[e]; });
                CKBJ[chartID].coord = CKB[chartID].coord.map(function (e) { return translator_1.concepts.coord[e]; });
                CKBJ[chartID].category = CKB[chartID].category.map(function (e) { return translator_1.concepts.category[e]; });
                CKBJ[chartID].shape = CKB[chartID].shape.map(function (e) { return translator_1.concepts.shape[e]; });
                CKBJ[chartID].channel = CKB[chartID].channel.map(function (e) { return translator_1.concepts.channel[e]; });
                CKBJ[chartID].dataPres = CKB[chartID].dataPres.map(function (e) {
                    var dataPreJ = {};
                    dataPreJ.minQty = e.minQty;
                    dataPreJ.maxQty = e.maxQty;
                    dataPreJ.fieldConditions = e.fieldConditions.map(function (l) { return translator_1.concepts.lom[l]; });
                    return dataPreJ;
                });
            });
        }
    }
    else {
        CKBJ = CKB;
    }
    return CKBJ;
}
/**
 * @param chartKnowledge - Knowledge of the added chart.
 * @param trans - Versions of translation for the name, alias and definition of the added chart.
 * @deprecated
 * @public
 */
export function addChart(chartKnowledge, trans) {
    var id = chartKnowledge.id;
    base[id] = chartKnowledge;
    var langs = Object.keys(trans);
    langs.forEach(function (lang) {
        var transList = translateMapping[lang];
        if (!transList) {
            // do nothing
        }
        else {
            transList.chartTypes[id] = trans[lang];
        }
    });
}
