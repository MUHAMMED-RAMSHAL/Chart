"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.convertDataType = exports.getStringifyLength = exports.stringify = exports.generateSplit = exports.fillMissingValue = exports.flatObject = exports.generateArrayIndex = exports.isAxis = void 0;
var tslib_1 = require("tslib");
var is_date_1 = require("../analyzer/is-date");
var utils_1 = require("../utils");
var isAxis = function (value) {
    return utils_1.isNumber(value) || utils_1.isString(value);
};
exports.isAxis = isAxis;
// generate indexes for 1D and 2D array
var generateArrayIndex = function (data, extraIndex) {
    utils_1.assert(utils_1.isArray(data), 'Data must be an array');
    if (extraIndex) {
        utils_1.assert((extraIndex === null || extraIndex === void 0 ? void 0 : extraIndex.length) === data.length, "Index length is " + (extraIndex === null || extraIndex === void 0 ? void 0 : extraIndex.length) + ", but data size is " + data.length);
        return extraIndex;
    }
    return utils_1.range(data.length);
};
exports.generateArrayIndex = generateArrayIndex;
var flatObject = function (obj, concatenator) {
    if (concatenator === void 0) { concatenator = '.'; }
    return Object.keys(obj).reduce(function (acc, key) {
        var _a;
        if (typeof obj[key] !== 'object' || obj[key] === null) {
            return tslib_1.__assign(tslib_1.__assign({}, acc), (_a = {}, _a[key] = obj[key], _a));
        }
        var flattenedChild = exports.flatObject(obj[key], concatenator);
        return tslib_1.__assign(tslib_1.__assign({}, acc), Object.keys(flattenedChild).reduce(function (childAcc, childKey) {
            var _a;
            return (tslib_1.__assign(tslib_1.__assign({}, childAcc), (_a = {}, _a["" + key + concatenator + childKey] = flattenedChild[childKey], _a)));
        }, {}));
    }, {});
};
exports.flatObject = flatObject;
var fillMissingValue = function (datum, fillValue) {
    return !datum && JSON.stringify(fillValue) ? fillValue : datum;
};
exports.fillMissingValue = fillMissingValue;
var generateSplit = function (length) {
    return Array(utils_1.isNumber(length) ? length : 0)
        .fill(' ')
        .concat('  ')
        .join('');
};
exports.generateSplit = generateSplit;
var stringify = function (value) {
    var _a, _b, _c, _d, _e, _f;
    return ((_f = (_e = (_d = (_c = (_b = (_a = JSON.stringify(value)) === null || _a === void 0 ? void 0 : _a.replace(/\\n/g, '')) === null || _b === void 0 ? void 0 : _b.replace(/\\/g, '')) === null || _c === void 0 ? void 0 : _c.replace(/"\[/g, '[')) === null || _d === void 0 ? void 0 : _d.replace(/\]"/g, ']')) === null || _e === void 0 ? void 0 : _e.replace(/"\{/g, '{')) === null || _f === void 0 ? void 0 : _f.replace(/\}"/g, ' }')) || 'undefined';
};
exports.stringify = stringify;
var getStringifyLength = function (value) { var _a; return (_a = exports.stringify(value)) === null || _a === void 0 ? void 0 : _a.length; };
exports.getStringifyLength = getStringifyLength;
/**
 * Convert data to specified data type.
 * @param datum
 * @param type
 * @returns converted data
 */
var convertDataType = function (data, type) {
    try {
        if (type === 'string' && !utils_1.isString(data)) {
            return "" + data;
        }
        if (type === 'boolean' && !utils_1.isBoolean(data)) {
            return Boolean(data);
        }
        if (type === 'null' && !utils_1.isNull(data)) {
            return null;
        }
        if ((type === 'integer' || type === 'float') && !utils_1.isNumber(data)) {
            return +data;
        }
        if (type === 'date' && !is_date_1.isDateString("" + data)) {
            return new Date(data);
        }
    }
    catch (error) {
        throw new Error(error);
    }
    return data;
};
exports.convertDataType = convertDataType;
