"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var utils_1 = require("../utils");
var utils_2 = require("./utils");
var base_frame_1 = tslib_1.__importDefault(require("./base-frame"));
/** 1D data structure */
var Series = /** @class */ (function (_super) {
    tslib_1.__extends(Series, _super);
    function Series(data, extra) {
        var _a, _b, _c, _d;
        var _this = _super.call(this, data, extra) || this;
        utils_1.assert(utils_1.isObject(data) || utils_1.isBasicType(data) || utils_1.isArray(data), 'Data type is illegal');
        /** 1D: object */
        if (utils_1.isObject(data)) {
            // generate indexes
            var indexes = Object.keys(data);
            if (extra === null || extra === void 0 ? void 0 : extra.indexes) {
                utils_1.assert(((_a = extra === null || extra === void 0 ? void 0 : extra.indexes) === null || _a === void 0 ? void 0 : _a.length) <= indexes.length, "Index length " + ((_b = extra === null || extra === void 0 ? void 0 : extra.indexes) === null || _b === void 0 ? void 0 : _b.length) + " is greater than data size " + indexes.length);
                for (var i = 0; i < (extra === null || extra === void 0 ? void 0 : extra.indexes.length); i += 1) {
                    var idx = extra === null || extra === void 0 ? void 0 : extra.indexes[i];
                    if (indexes.includes(idx)) {
                        _this.data.push(utils_2.convertDataType(utils_2.fillMissingValue(data[idx], extra === null || extra === void 0 ? void 0 : extra.fillValue), (_c = extra === null || extra === void 0 ? void 0 : extra.columnTypes) === null || _c === void 0 ? void 0 : _c[0]));
                    }
                }
                _this.setAxis(0, extra === null || extra === void 0 ? void 0 : extra.indexes);
            }
            else {
                _this.data = Object.values(data).map(function (datum) { var _a; return utils_2.convertDataType(utils_2.fillMissingValue(datum, extra === null || extra === void 0 ? void 0 : extra.fillValue), (_a = extra === null || extra === void 0 ? void 0 : extra.columnTypes) === null || _a === void 0 ? void 0 : _a[0]); });
                _this.setAxis(0, indexes);
            }
        }
        else if (utils_1.isArray(data)) {
            /** 1D: array */
            var _e = tslib_1.__read(data, 1), data0 = _e[0];
            if (!utils_1.isBasicType(data0)) {
                if (extra === null || extra === void 0 ? void 0 : extra.indexes) {
                    utils_1.assert(((_d = extra === null || extra === void 0 ? void 0 : extra.indexes) === null || _d === void 0 ? void 0 : _d.length) === data.length, "Index length is " + (extra === null || extra === void 0 ? void 0 : extra.indexes.length) + ", but data size " + data.length);
                    _this.setAxis(0, extra === null || extra === void 0 ? void 0 : extra.indexes);
                }
                _this.data = data;
            }
        }
        return _this;
    }
    Object.defineProperty(Series.prototype, "shape", {
        get: function () {
            return [this.axes[0].length];
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Get data by row location and column location.
     * @param rowLoc
     */
    Series.prototype.get = function (rowLoc) {
        utils_1.assert(utils_1.isNumber(rowLoc) ||
            (utils_1.isString(rowLoc) && !rowLoc.includes(':')) ||
            utils_1.isArray(rowLoc) ||
            (utils_1.isString(rowLoc) && rowLoc.includes(':')), 'The rowLoc is illegal');
        // input is like 0 || 'a'
        if (utils_1.isNumber(rowLoc) || (utils_1.isString(rowLoc) && !rowLoc.includes(':'))) {
            utils_1.assert(this.indexes.includes(rowLoc), 'The rowLoc is not found in the indexes.');
            if (utils_1.isNumber(rowLoc)) {
                return this.data[rowLoc];
            }
            if (utils_1.isString(rowLoc)) {
                var rowIdx = this.indexes.indexOf(rowLoc);
                return this.data[rowIdx];
            }
        }
        if (utils_1.isArray(rowLoc)) {
            // input is like [0, 1, 2] || ['a', 'b', 'c']
            var newData = [];
            var newIndex = [];
            for (var i = 0; i < rowLoc.length; i += 1) {
                var loc = rowLoc[i];
                utils_1.assert(this.indexes.includes(loc), 'The rowLoc is not found in the indexes.');
                var idxInIndex = this.indexes.indexOf(loc);
                newData.push(this.data[idxInIndex]);
                newIndex.push(this.indexes[idxInIndex]);
            }
            return new Series(newData, { indexes: newIndex });
        }
        if (utils_1.isString(rowLoc) && rowLoc.includes(':')) {
            // input is like '0:2' || 'a:c'
            var rowLocArr = rowLoc.split(':');
            utils_1.assert(rowLocArr.length === 2, 'The rowLoc is not found in the indexes.');
            var startLoc = rowLocArr[0];
            var endLoc = rowLocArr[1];
            if (utils_1.isInteger(Number(startLoc)) && utils_1.isInteger(Number(endLoc))) {
                var startIdx = Number(startLoc);
                var endIdx = Number(endLoc);
                var newData = this.data.slice(startIdx, endIdx);
                var newIndex = this.indexes.slice(startIdx, endIdx);
                return new Series(newData, { indexes: newIndex });
            }
            if (utils_1.isString(startLoc) && utils_1.isString(endLoc)) {
                var startIdx = this.indexes.indexOf(startLoc);
                var endIdx = this.indexes.indexOf(endLoc);
                var newData = this.data.slice(startIdx, endIdx);
                var newIndex = this.indexes.slice(startIdx, endIdx);
                return new Series(newData, { indexes: newIndex });
            }
        }
        throw new Error('The rowLoc is illegal');
    };
    /**
     * Get data by row location and column location using integer index.
     * @param rowLoc
     */
    Series.prototype.getByIndex = function (rowLoc) {
        utils_1.assert(utils_1.isInteger(rowLoc) || utils_1.isArray(rowLoc) || (utils_1.isString(rowLoc) && rowLoc.includes(':')), 'The rowLoc is illegal');
        // input is like 1
        if (utils_1.isInteger(rowLoc)) {
            utils_1.assert(utils_1.range(this.indexes.length).includes(rowLoc), 'The rowLoc is not found in the indexes.');
            if (utils_1.range(this.indexes.length).includes(rowLoc)) {
                return this.data[rowLoc];
            }
        }
        if (utils_1.isArray(rowLoc)) {
            // input is like [0, 1, 2]
            var newData = [];
            var newIndex = [];
            for (var i = 0; i < rowLoc.length; i += 1) {
                var idx = rowLoc[i];
                utils_1.assert(utils_1.range(this.indexes.length).includes(idx), 'The rowLoc is not found in the indexes.');
                newData.push(this.data[idx]);
                newIndex.push(this.indexes[idx]);
            }
            return new Series(newData, { indexes: newIndex });
        }
        if (utils_1.isString(rowLoc) && rowLoc.includes(':')) {
            // input is like '0:2'
            var rowLocArr = rowLoc.split(':');
            if (rowLocArr.length === 2) {
                var startIdx = Number(rowLocArr[0]);
                var endIdx = Number(rowLocArr[1]);
                utils_1.assert(utils_1.isInteger(startIdx) && utils_1.isInteger(endIdx), 'The rowLoc is not found in the indexes.');
                var newData = this.data.slice(startIdx, endIdx);
                var newIndex = this.indexes.slice(startIdx, endIdx);
                return new Series(newData, { indexes: newIndex });
            }
        }
        throw new Error('The rowLoc is illegal');
    };
    return Series;
}(base_frame_1.default));
exports.default = Series;
