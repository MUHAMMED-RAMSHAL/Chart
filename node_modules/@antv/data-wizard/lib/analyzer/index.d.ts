import type { LevelOfMeasurement } from '@antv/ckb';
/**
 * Field Type
 * @public
 */
export declare type TypeSpecifics = 'null' | 'boolean' | 'integer' | 'float' | 'date' | 'string';
/**
 * basic info of field
 * @public
 */
export interface FieldInfo {
    /** field name */
    name?: string;
    /** field type */
    type: TypeSpecifics | 'mixed';
    /** recommendation type */
    recommendation: TypeSpecifics;
    /** number of empty inclues null undefined or empty string */
    missing?: number;
    /** distinct count */
    distinct?: number;
    /** Number of each distinct item */
    valueMap?: Record<string, number>;
    /** count of rawData */
    count?: number;
    /** rawData */
    rawData: any[];
    /** more info */
    meta?: FieldMeta;
    /** level of measurements */
    levelOfMeasurements?: LevelOfMeasurement[];
}
/**
 * String Field
 * @public
 */
export interface StringFieldInfo extends FieldInfo {
    /** max length */
    maxLength: number;
    /** min length */
    minLength: number;
    /** mean of length */
    meanLength: number;
    /** is contain charts */
    containsChar: boolean;
    /**  is contain digits */
    containsDigit: boolean;
    /** is contain white space */
    containsSpace: boolean;
}
/**
 * @public
 */
export declare function isStringFieldInfo(x: FieldInfo): x is StringFieldInfo;
/**
 * Number Field
 * @public
 */
export interface NumberFieldInfo extends FieldInfo {
    /** the counts of zero value */
    zeros: number;
    /** minimum */
    minimum: number;
    /** 5% percentile */
    percentile5: number;
    /** 25% percentile */
    percentile25: number;
    /** 50% percentile */
    percentile50: number;
    /** 75% percentile */
    percentile75: number;
    /** 95% percentile */
    percentile95: number;
    /** maximum */
    maximum: number;
    /** standardDeviation */
    standardDeviation: number;
    /** mean */
    mean: number;
    /** sum */
    sum: number;
    /** variance */
    variance: number;
}
/**
 * @public
 */
export declare function isNumberFieldInfo(x: FieldInfo): x is NumberFieldInfo;
/**
 * Date Field
 * @public
 */
export interface DateFieldInfo extends FieldInfo {
    /** minimum date */
    minimum: string | number | Date;
    /** maximum date */
    maximum: string | number | Date;
}
/**
 * @public
 */
export declare function isDateFieldInfo(x: FieldInfo): x is DateFieldInfo;
/**
 * The field meta which be exsit only the Field type is mixed
 * @public
 */
export declare type FieldMeta = {
    integer?: NumberFieldInfo;
    float?: NumberFieldInfo;
    date?: DateFieldInfo;
    string?: StringFieldInfo;
};
export declare type NodeStructFeat = {
    degree: number;
    inDegree: number;
    outDegree: number;
    pageRank: number;
    closeness: number;
    kCore: number;
    cycleCount: number;
    triangleCount: number;
    starCount: number;
    cliqueCount: number;
    clusterCoeff: number;
};
export declare type LinkStructFeat = {
    isDirected: Boolean;
    centrality: number;
    cycleCount: number;
    triangleCount: number;
    starCount: number;
    cliqueCount: number;
};
export declare type GraphFeat = {
    nodeCount: number;
    linkCount: number;
    direction: number;
    isDirected: Boolean;
    isDAG: Boolean;
    isCycle: Boolean;
    isConnected: Boolean;
    ratio: number;
    breadth: number;
    depth: number;
    maxDegree: number;
    minDegree: number;
    avgDegree: number;
    degreeStd: number;
    maxPageRank: number;
    minPageRank: number;
    avgPageRank: number;
    components: any[];
    componentCount: number;
    strongConnectedComponents: any[];
    strongConnectedComponentCount: number;
    cycleCount: number;
    directedCycleCount: number;
    starCount: number;
    cliqueCount: number;
    cycleParticipate: number;
    triangleCount: number;
    localClusterCoeff: number;
    globalClusterCoeff: number;
    maxKCore: number;
};
export declare type GraphProps = {
    nodeFeats: FieldInfo[];
    linkFeats: FieldInfo[];
    graphInfo: Partial<GraphFeat>;
    nodeFieldsInfo: FieldInfo[];
    linkFieldsInfo: FieldInfo[];
    [key: string]: any;
};
export declare function analyzeString(array: string[]): Omit<StringFieldInfo, keyof FieldInfo>;
export declare function analyzeNumber(array: number[]): Omit<NumberFieldInfo, keyof FieldInfo>;
export declare function analyzeDate(array: Array<string | Date>, isInteger?: boolean): Omit<DateFieldInfo, keyof FieldInfo>;
/**
 * Determine what type a value is, may be one of [integer float date string null]
 */
export declare function analyzeType(value: any): 'null' | 'integer' | 'float' | 'date' | 'string';
/**
 * Checks if field is constant
 * @param info - The {@link FieldInfo} to processs
 * @public
 */
export declare function isConst(info: FieldInfo): boolean;
/**
 * Checks if field is an ordinal
 * @param info - Field Info
 * @public
 */
export declare function isOrdinal(info: FieldInfo): boolean;
/**
 * Checks if field is an unique
 * @param info - The {@link FieldInfo} to processs
 * @public
 */
export declare function isUnique(info: FieldInfo): boolean;
/**
 * Checks if field is discrete
 * @remarks
 * @param info - The {@link FieldInfo} to processs
 * @public
 */
export declare function isDiscrete(info: FieldInfo): boolean;
/**
 * Checks if field is a continuous.
 * @param info - The {@link FieldInfo} to processs
 * @public
 */
export declare function isContinuous(info: FieldInfo): boolean;
/**
 * Checks if field is an interval
 * @param info - The {@link FieldInfo} to processs
 * @public
 */
export declare function isInterval(info: FieldInfo): boolean;
/**
 * Checks if field is a nominal
 * @param info - The {@link FieldInfo} to processs
 * @public
 */
export declare function isNominal(info: FieldInfo): boolean;
/**
 * Checks if field is a time
 * @param info - Field Info
 * @public
 */
export declare function isTime(info: FieldInfo): boolean;
/**
 * Analysis field type
 * @param array - data
 * @public
 */
export declare function analyzeField(array: any[]): StringFieldInfo | NumberFieldInfo | DateFieldInfo;
