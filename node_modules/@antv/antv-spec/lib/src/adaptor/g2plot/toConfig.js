"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.specToG2PlotConfig = exports.markToChart = void 0;
const schema_1 = require("../../schema");
const CHART_TYPES_WITH_STACK = ['Area', 'Column', 'Bar'];
/**
 * get chart type (Line / Bar / ...) from spec's mark (bar / line / ...)
 * @param spec input spec
 * @returns chart type
 */
function markToChart(spec) {
    if (spec.layer.length === 1) {
        const layer = spec.layer[0];
        const mark = typeof layer.mark === 'string' ? layer.mark : layer.mark.type;
        let chartType;
        switch (mark) {
            case 'line':
                chartType = 'Line';
                break;
            case 'area':
                chartType = 'Area';
                break;
            case 'point':
                chartType = 'Scatter';
                break;
            case 'arc':
                // pie and donut are all Pie(), with/without innerRadius
                chartType = 'Pie';
                break;
            case 'bar': {
                const hasX = layer.encoding.x;
                const xType = hasX ? hasX.type : '';
                if (xType === 'quantitative') {
                    chartType = 'Bar';
                }
                else {
                    chartType = 'Column';
                }
                break;
            }
            case 'rect':
                chartType = 'Heatmap';
                break;
            default:
                chartType = '';
                break;
        }
        return chartType;
    }
    // TODO: other chart types (dual axea, etc)
    return '';
}
exports.markToChart = markToChart;
/**
 * translate antv-spec to g2plot configuration
 * @param spec
 * @returns configuration to plot g2plot
 */
function specToG2PlotConfig(spec) {
    // g2plot configuration
    const config = {};
    // chart type and g2plot config (to return)
    const configs = {
        chartType: '',
        config,
    };
    // step 1: convert chart type
    const chartType = markToChart(spec);
    configs.chartType = chartType;
    // if not valid g2plot type or not supported yet
    if (!chartType) {
        return {
            chartType: '',
            config,
        };
    }
    // step 2: convert basis
    if (spec.basis) {
        const { basis } = spec;
        // to remove `type` in basis because G2Plot config has property with same name
        const { type, ...basisWithoutType } = basis;
        if (type !== 'chart') {
            return {
                chartType: '',
                config,
            };
        }
        configs.config = basisWithoutType;
    }
    // step 3: convert mark style
    if (spec.layer.length === 1 && 'mark' in spec.layer[0]) {
        if (typeof spec.layer[0].mark !== 'string') {
            // object style to describe 'mark'
            if (spec.layer[0].mark.style) {
                const styles = spec.layer[0].mark.style;
                // for donut chart
                if (styles.innerRadius) {
                    // TODO actual innerRadius
                    // user input innerRadius may be `px`, but G2Plot treat it as the ratio to the drawing area
                    configs.config.innerRadius = styles.innerRadius >= 0 && styles.innerRadius < 1 ? styles.innerRadius : 0.6;
                }
                // for single color declaration of mark
                if (styles.color) {
                    configs.config.color = styles.color;
                }
            }
            // line chart && area chart
            if (spec.layer[0].mark.interpolate) {
                if (spec.layer[0].mark.interpolate === 'step') {
                    // TODO allow user input hv | vh | hvh | vhv
                    configs.config.stepType = 'vh';
                }
                else if (['hv', 'vh', 'vhv', 'hvh'].includes(spec.layer[0].mark.interpolate)) {
                    configs.config.stepType = spec.layer[0].mark.interpolate;
                }
            }
        }
    }
    // step 4: convert data
    if (spec.data.type === 'json-array') {
        configs.config.data = spec.data.values;
    }
    // step 5: convert encoding
    if (spec.layer.length === 1 && 'encoding' in spec.layer[0]) {
        const layer = spec.layer[0];
        Object.keys(layer.encoding).forEach((key) => {
            var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q;
            if (key === 'column' && chartType === 'Column') {
                configs.config.xField = (_a = layer.encoding[key]) === null || _a === void 0 ? void 0 : _a.field;
            }
            if (key === 'row' && chartType === 'Bar') {
                configs.config.yField = (_b = layer.encoding[key]) === null || _b === void 0 ? void 0 : _b.field;
            }
            if (key === 'x' || key === 'y') {
                if (chartType === 'Column' && 'column' in layer.encoding && key === 'x') {
                    configs.config.seriesField = (_c = layer.encoding[key]) === null || _c === void 0 ? void 0 : _c.field;
                    configs.config.isGroup = true;
                }
                else if (chartType === 'Bar' && 'row' in layer.encoding && key === 'y') {
                    configs.config.seriesField = (_d = layer.encoding[key]) === null || _d === void 0 ? void 0 : _d.field;
                    configs.config.isGroup = true;
                }
                else {
                    configs.config[`${key}Field`] = (_e = layer.encoding[key]) === null || _e === void 0 ? void 0 : _e.field;
                }
                // check if percentage stacking
                if ((_f = layer.encoding[key]) === null || _f === void 0 ? void 0 : _f.stack) {
                    if (((_g = layer.encoding[key]) === null || _g === void 0 ? void 0 : _g.stack) === 'normalize') {
                        configs.config.isPercent = true;
                    }
                }
                // axis config
                const tmpAxis = (_h = layer.encoding[key]) === null || _h === void 0 ? void 0 : _h.axis;
                const tmpAxisCfg = {};
                schema_1.AxisProps.forEach((prop) => {
                    var _a, _b, _c, _d;
                    if (prop === 'title') {
                        const tmpTitle = (_b = (_a = layer.encoding[key]) === null || _a === void 0 ? void 0 : _a.axis) === null || _b === void 0 ? void 0 : _b.title;
                        if (tmpTitle) {
                            const tmpTitleCfg = {};
                            schema_1.AxisTitleProps.forEach((prop) => {
                                if (tmpTitle && Object.prototype.hasOwnProperty.call(tmpTitle, prop)) {
                                    tmpTitleCfg[prop] = tmpTitle[prop];
                                }
                            });
                            tmpAxisCfg.title = tmpTitleCfg;
                        }
                    }
                    else if (prop === 'label') {
                        const tmpLabel = (_d = (_c = layer.encoding[key]) === null || _c === void 0 ? void 0 : _c.axis) === null || _d === void 0 ? void 0 : _d.label;
                        if (tmpLabel) {
                            const tmpLabelCfg = {};
                            schema_1.AxisLabelProps.forEach((prop) => {
                                if (tmpLabel && Object.prototype.hasOwnProperty.call(tmpLabel, prop)) {
                                    tmpLabelCfg[prop === 'angle' ? 'rotate' : prop] = tmpLabel[prop];
                                }
                            });
                            tmpAxisCfg.label = tmpLabelCfg;
                        }
                    }
                    else if (tmpAxis && Object.prototype.hasOwnProperty.call(tmpAxis, prop)) {
                        tmpAxisCfg[prop] = tmpAxis[prop];
                        if (prop === 'min' || prop === 'max') {
                            tmpAxisCfg[`${prop}Limit`] = tmpAxis[prop];
                        }
                    }
                });
                if (tmpAxis) {
                    configs.config[`${key}Axis`] = tmpAxisCfg;
                }
            }
            else if (key === 'size') {
                configs.config.sizeField = (_j = layer.encoding[key]) === null || _j === void 0 ? void 0 : _j.field;
                // TODO: size scale need to be determined by input
                configs.config.size = [10, 30];
            }
            else if (key === 'theta') {
                configs.config.angleField = (_k = layer.encoding[key]) === null || _k === void 0 ? void 0 : _k.field;
            }
            else if (key === 'color') {
                // if have color encoding, ignore color setting in mark style
                if (Object.keys(configs.config).includes('color')) {
                    delete configs.config.color;
                }
                if (CHART_TYPES_WITH_STACK.includes(chartType) || chartType === 'Line') {
                    // stacking
                    configs.config.seriesField = (_l = layer.encoding[key]) === null || _l === void 0 ? void 0 : _l.field;
                    configs.config.isStack = true;
                }
                else {
                    configs.config.colorField = (_m = layer.encoding[key]) === null || _m === void 0 ? void 0 : _m.field;
                }
                if (((_o = layer.encoding[key]) === null || _o === void 0 ? void 0 : _o.scale) && ((_p = layer.encoding[key]) === null || _p === void 0 ? void 0 : _p.scale.range)) {
                    // define color
                    configs.config.color = (_q = layer.encoding[key]) === null || _q === void 0 ? void 0 : _q.scale.range;
                }
            }
        });
    }
    return configs;
}
exports.specToG2PlotConfig = specToG2PlotConfig;
//# sourceMappingURL=toConfig.js.map