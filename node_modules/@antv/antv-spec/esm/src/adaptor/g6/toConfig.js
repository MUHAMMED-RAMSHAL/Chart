const DEFAULT_WIDTH = 1000;
const DEFAULT_HEIGHT = 600;
/** Linear scale */
const linearScaleMap = (scale, x) => {
    const minRange = Math.min(...scale.range);
    const minDomain = Math.min(...scale.domain);
    const maxRange = Math.max(...scale.range);
    const maxDomain = Math.max(...scale.domain);
    return ((maxRange - minRange) / (maxDomain - minDomain)) * (x - minDomain) + minRange;
};
export function specToG6Config(spec) {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    const config = {};
    const g6Cfg = {
        cfg: config,
        data: {},
    };
    if (spec.basis) {
        g6Cfg.cfg.height = ((_a = spec.basis) === null || _a === void 0 ? void 0 : _a.height) || DEFAULT_HEIGHT;
        g6Cfg.cfg.width = ((_b = spec.basis) === null || _b === void 0 ? void 0 : _b.width) || DEFAULT_WIDTH;
    }
    if ('layout' in spec) {
        const layoutCfg = {};
        if ((_c = spec.layout) === null || _c === void 0 ? void 0 : _c.type) {
            layoutCfg.type = spec.layout.type;
            layoutCfg.options = spec.layout.options;
        }
        g6Cfg.cfg.layout = layoutCfg;
    }
    // convert data to { "nodes": [{...}, ], "links": [{...}, ]}
    const dataVals = spec.data.values;
    const g6Data = {};
    const nodeKey = spec.layout.nodes;
    const linkKey = spec.layout.links;
    g6Data.nodes = dataVals[nodeKey];
    g6Data.edges = dataVals[linkKey];
    // mapping size/color encoding of edges and nodes in data
    const { nodes } = g6Data;
    nodes.forEach((node) => {
        const updateNode = node;
        updateNode.oriSize = updateNode.size;
        updateNode.oriLabel = updateNode.label;
        return updateNode;
    });
    const nodesEnc = 'nodes' in spec.layer[0] ? spec.layer[0].nodes : null;
    if (nodesEnc) {
        if (nodesEnc.mark) {
            nodes.forEach((node) => {
                const updateNode = node;
                updateNode.type = nodesEnc.mark === 'point' ? 'circle' : nodesEnc.mark;
            });
        }
        if ((_d = nodesEnc.encoding) === null || _d === void 0 ? void 0 : _d.color) {
            // have color encoding for nodes
            const { field, scale } = nodesEnc.encoding.color;
            const colorMap = new Map();
            let colorId = 0;
            if (scale) {
                nodes.forEach((node) => {
                    const updateNode = node;
                    if (node[field] && colorMap.get(node[field]) === undefined) {
                        colorMap.set(node[field], colorId);
                        colorId += 1;
                    }
                    const cid = colorMap.get(node[field]);
                    if (!updateNode.style)
                        updateNode.style = {};
                    updateNode.style.fill = scale.range[cid % scale.range.length];
                    updateNode.style.stroke = scale.range[cid % scale.range.length];
                    return updateNode;
                });
            }
        }
        if ((_e = nodesEnc.encoding) === null || _e === void 0 ? void 0 : _e.size) {
            // have size encoding for nodes
            const { field, scale } = nodesEnc.encoding.size;
            if (scale) {
                nodes.forEach((node) => {
                    const updateNode = node;
                    updateNode.size = updateNode.size || linearScaleMap(scale, updateNode[field]);
                    if (updateNode.type === 'rect') {
                        updateNode.size = [updateNode.size * 2, updateNode.size];
                    }
                    return updateNode;
                });
            }
        }
        if ((_f = nodesEnc.encoding) === null || _f === void 0 ? void 0 : _f.label) {
            const { field } = nodesEnc.encoding.label;
            nodes.forEach((node) => {
                const updateNode = node;
                updateNode.label = updateNode.label || updateNode[field];
                return updateNode;
            });
        }
    }
    const { edges } = g6Data;
    const edgesEnc = 'links' in spec.layer[0] ? spec.layer[0].links : null;
    if (edgesEnc) {
        if (edgesEnc.mark) {
            edges.forEach((edge) => {
                const updateEdge = edge;
                updateEdge.type = edgesEnc.mark;
            });
        }
        if ((_g = edgesEnc.encoding) === null || _g === void 0 ? void 0 : _g.color) {
            // have color encoding for edges
            const { field, scale } = edgesEnc.encoding.color;
            const colorMap = new Map();
            let colorId = 0;
            if (scale) {
                edges.forEach((edge) => {
                    const updateEdge = edge;
                    if (edge[field] && colorMap.get(edge[field]) === undefined) {
                        colorMap.set(edge[field], colorId);
                        colorId += 1;
                    }
                    const cid = colorMap.get(edge[field]);
                    if (!updateEdge.style)
                        updateEdge.style = {};
                    updateEdge.style.stroke = scale.range[cid % scale.range.length];
                    return updateEdge;
                });
            }
        }
        if ((_h = edgesEnc.encoding) === null || _h === void 0 ? void 0 : _h.size) {
            // have size encoding for edges
            const { field, scale } = edgesEnc.encoding.size;
            if (scale) {
                edges.forEach((edge) => {
                    const updateEdge = edge;
                    if (!updateEdge.style)
                        updateEdge.style = {};
                    updateEdge.style.lineWidth = linearScaleMap(scale, updateEdge[field]);
                    return updateEdge;
                });
            }
        }
    }
    g6Cfg.data = g6Data;
    g6Cfg.cfg.linkCenter = true;
    g6Cfg.cfg.modes = {
        default: ['drag-canvas', 'zoom-canvas', 'drag-node'], // default canvas interactions
    };
    return g6Cfg;
}
//# sourceMappingURL=toConfig.js.map