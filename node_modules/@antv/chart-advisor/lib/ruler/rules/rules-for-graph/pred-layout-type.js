"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.allLayoutTypeRules = exports.shouldUseGrid = exports.shouldUseConcentric = exports.shouldUseForce = exports.shouldUseCircular = exports.shouldUseRadial = exports.shouldUseDagre = void 0;
var constants_1 = require("../../../constants");
var applyChartTypes = ['graph'];
var MAX_SCORE = 5;
// Option 1. Score evaluation criteria: 0 - not recommended; 5 - highly recommended
/**
 * Conditions suitable for using the Dagre layout
 * 1. Directed acyclic diagram / number of cycles should be small 有向无环或少环图
 * 2. The breath of each level should be less than MAX_BREADH 宽度不宜过宽 / 每层节点不宜过多
 * 3. The number of nodes should be less than a certain number 节点个数不宜过多（暂时没有限制）
 */
exports.shouldUseDagre = {
    id: 'use-dagre-rule',
    type: 'SOFT',
    docs: {
        detailedText: '',
    },
    trigger: function (_a) {
        var chartType = _a.chartType;
        return applyChartTypes.indexOf(chartType) !== -1;
    },
    validator: function (graphProps) {
        var score = 0;
        var _a = graphProps === null || graphProps === void 0 ? void 0 : graphProps.graphInfo, isDAG = _a.isDAG, cycleParticipate = _a.cycleParticipate, maxDegree = _a.maxDegree, avgDegree = _a.avgDegree;
        if (isDAG) {
            score = 1;
        }
        if (maxDegree <= constants_1.MAX_NUM_NODES_A_LEVEL / 2) {
            score += 1;
        }
        if (avgDegree < constants_1.MAX_NUM_NODES_A_LEVEL / 3) {
            score += 1;
        }
        if (cycleParticipate > 0.5) {
            score = 0;
        }
        else if (cycleParticipate < 0.3) {
            score += 2;
        }
        return score / MAX_SCORE;
    },
};
/**
 * Conditions suitable for using the Radial layout
 * 1. has one or several focus nodes
 * 2. number of cycles is small
 * 3. The breath of each level could be more than which of Dagre layout
 */
exports.shouldUseRadial = {
    id: 'use-radial-rule',
    type: 'SOFT',
    docs: {
        detailedText: '',
    },
    trigger: function (_a) {
        var chartType = _a.chartType;
        return applyChartTypes.indexOf(chartType) !== -1;
    },
    validator: function (graphProps) {
        var score = 0;
        var _a = graphProps === null || graphProps === void 0 ? void 0 : graphProps.graphInfo, isDAG = _a.isDAG, cycleParticipate = _a.cycleParticipate, maxDegree = _a.maxDegree;
        if (isDAG) {
            score = 1;
        }
        if (maxDegree > constants_1.MAX_NUM_NODES_A_LEVEL / 2 && maxDegree < constants_1.MAX_NUM_NODES_A_LEVEL) {
            score += 1;
        }
        if (cycleParticipate > 0.5) {
            score = 0;
        }
        else if (cycleParticipate < 0.3) {
            score += 1;
        }
        var hasFocusNode = false;
        if (hasFocusNode) {
            score += 2;
        }
        return score / MAX_SCORE;
    },
};
/**
 * Conditions suitable for using the Circular layout
 * 1. The graph has cycles and a high percentage of cycles (a larger percentage of nodes in cycles). 图中有圆环且圆环占比较高（处于圆环的节点比例较大）
 */
exports.shouldUseCircular = {
    id: 'use-circular-rule',
    type: 'SOFT',
    docs: {
        detailedText: '',
    },
    trigger: function (_a) {
        var chartType = _a.chartType;
        return applyChartTypes.indexOf(chartType) !== -1;
    },
    validator: function (graphProps) {
        var score = 0;
        var _a = graphProps === null || graphProps === void 0 ? void 0 : graphProps.graphInfo, cycleCount = _a.cycleCount, cycleParticipate = _a.cycleParticipate;
        if (cycleCount > 0)
            score = 2;
        if (cycleParticipate >= 0.5 && cycleParticipate <= 0.8) {
            score = 3;
        }
        else if (cycleParticipate > 0.8 && cycleParticipate < 0.9) {
            score = 4;
        }
        else if (cycleParticipate >= 0.9) {
            score = 5;
        }
        return score / MAX_SCORE;
    },
};
/**
 * Conditions suitable for using the Force layout
 */
exports.shouldUseForce = {
    id: 'use-force-rule',
    type: 'SOFT',
    docs: {
        detailedText: '',
    },
    trigger: function (_a) {
        var chartType = _a.chartType;
        return applyChartTypes.indexOf(chartType) !== -1;
    },
    validator: function (graphProps) {
        var score = 0;
        var _a = graphProps === null || graphProps === void 0 ? void 0 : graphProps.graphInfo, nodeCount = _a.nodeCount, maxDegree = _a.maxDegree, avgDegree = _a.avgDegree, strongConnectedComponentCount = _a.strongConnectedComponentCount;
        if (nodeCount > 200) {
            score += 2;
        }
        if (strongConnectedComponentCount >= 1) {
            score += 1;
        }
        if (avgDegree < 3) {
            score += 1;
        }
        if (maxDegree > constants_1.MAX_NUM_NODES_A_LEVEL) {
            score += 1;
        }
        return score / MAX_SCORE;
    },
};
/**
 * Conditions suitable for using the Concentric layout
 * 1. 有中心程度很高的节点
 */
exports.shouldUseConcentric = {
    id: 'use-force-rule',
    type: 'SOFT',
    docs: {
        detailedText: '',
    },
    trigger: function (_a) {
        var chartType = _a.chartType;
        return applyChartTypes.indexOf(chartType) !== -1;
    },
    validator: function (graphProps) {
        var score = 0;
        var _a = graphProps === null || graphProps === void 0 ? void 0 : graphProps.graphInfo, maxDegree = _a.maxDegree, avgDegree = _a.avgDegree, degreeStd = _a.degreeStd;
        if (maxDegree - avgDegree > 3 * degreeStd) {
            score += 3;
        }
        return score / MAX_SCORE;
    },
};
/**
 * Conditions suitable for using the Grid layout
 */
exports.shouldUseGrid = {
    id: 'use-grid-rule',
    type: 'SOFT',
    docs: {
        detailedText: '',
    },
    trigger: function (_a) {
        var chartType = _a.chartType;
        return applyChartTypes.indexOf(chartType) !== -1;
    },
    validator: function () {
        var score = 0;
        return score;
    },
};
exports.allLayoutTypeRules = {
    dagre: exports.shouldUseDagre,
    circular: exports.shouldUseCircular,
    concentric: exports.shouldUseConcentric,
    radial: exports.shouldUseRadial,
    grid: exports.shouldUseGrid,
    force: exports.shouldUseForce,
};
