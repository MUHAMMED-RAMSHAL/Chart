import { __assign, __read } from "tslib";
import { allBuiltInRules, testRule } from '../../ruler/rules/rules-for-graph';
import { DEFAULT_COLORS, DEFAULT_NODE_SIZE_RANGE, DEFAULT_EDGE_WIDTH_RANGE, DEFAULT_LAYOUT_TYPE, ALL_LAYOUT_TYPES, } from '../../constants';
import { deepMix } from '../utils';
/**
 * map graph properties to layout configurations
 * @param dataProps
 * @return LayoutTypes[]
 */
export function graph2LayoutTypes(dataProps) {
    var candidates = [];
    ALL_LAYOUT_TYPES.forEach(function (layoutType) {
        var rule = allBuiltInRules[layoutType];
        candidates.push({
            type: layoutType,
            score: rule.validator(dataProps),
        });
    });
    var sortedTypes = candidates.filter(function (item) { return item.score > 0; }).sort(function (a, b) { return b.score - a.score; });
    if (!sortedTypes.length)
        sortedTypes.push({ type: DEFAULT_LAYOUT_TYPE, score: 1 });
    return sortedTypes;
}
/**
 * Recommended configurations based on the optimization policy and user configuration
 */
var optimizeByRule = function (dataProps, ruleId, graphSpec) {
    var rule = allBuiltInRules[ruleId];
    var result = rule.optimizer(dataProps, graphSpec);
    return result;
};
/**
 * map node data properties to points visual properties
 */
export function nodeFields2Style(dataProps, userCfg) {
    var nodeFeats = dataProps.nodeFeats, nodeFieldsInfo = dataProps.nodeFieldsInfo;
    var nodeFields = nodeFieldsInfo.concat(nodeFeats);
    // choose fields for encoding
    var _a = __read(testRule(nodeFields, 'field-for-color'), 1), fieldForColor = _a[0];
    var _b = __read(testRule(nodeFields, 'field-for-size'), 1), fieldForSize = _b[0];
    var _c = __read(testRule(nodeFields, 'field-for-label'), 1), fieldForLabel = _c[0];
    // optimize encoding configurations
    var colorScaleType = optimizeByRule(fieldForColor, 'pred-scale-type');
    var sizeScaleType = optimizeByRule(fieldForSize, 'pred-scale-type');
    var nodeType = optimizeByRule(dataProps, 'pred-node-type').nodeType;
    // convert configurations to AntVSpec
    var color = fieldForColor
        ? {
            field: fieldForColor.name,
            type: colorScaleType,
            scale: {
                range: (userCfg === null || userCfg === void 0 ? void 0 : userCfg.nodeColors) || DEFAULT_COLORS,
                domain: Object.keys(fieldForColor.valueMap),
            },
        }
        : {};
    var size = fieldForSize
        ? {
            field: fieldForSize.name,
            type: sizeScaleType,
            scale: {
                range: (userCfg === null || userCfg === void 0 ? void 0 : userCfg.nodeSizeRange) || DEFAULT_NODE_SIZE_RANGE,
                domain: [fieldForSize.minimum, fieldForSize.maximum],
            },
        }
        : {};
    var label = fieldForLabel
        ? {
            field: fieldForLabel.name,
            showlabel: true,
        }
        : {};
    var nodeSpec = {
        mark: nodeType || 'point',
        encoding: {
            size: size,
            color: color,
            label: label,
        },
    };
    return nodeSpec;
}
/**
 * map edge data properties to line visual properties
 */
/* eslint-disable no-param-reassign */
export function edgeFields2Style(dataProps, userCfg) {
    var linkFeats = dataProps.linkFeats, linkFieldsInfo = dataProps.linkFieldsInfo;
    var linkFields = linkFieldsInfo.concat(linkFeats);
    var _a = __read(testRule(linkFields, 'field-for-size'), 1), fieldForWidth = _a[0];
    var sizeScaleType = optimizeByRule(fieldForWidth, 'pred-scale-type');
    var edgeType = optimizeByRule(dataProps, 'pred-edge-type').edgeType;
    var size = fieldForWidth
        ? {
            field: fieldForWidth.name,
            type: sizeScaleType,
            scale: {
                range: (userCfg === null || userCfg === void 0 ? void 0 : userCfg.linkWidthRange) || DEFAULT_EDGE_WIDTH_RANGE,
                domain: [fieldForWidth.minimum, fieldForWidth.maximum],
            },
        }
        : {};
    var links = {
        mark: 'line',
        encoding: {
            size: size,
            type: edgeType,
        },
    };
    return links;
}
/**
 * recommending graph visualization given graph dataProps
 * @param dataProps data props derived from data-wizard or customized by users
 */
/* eslint-disable no-param-reassign */
export function graphdataToAdvices(data, dataProps, options) {
    var recommendSpecs = [];
    var basics = {
        data: {
            type: 'json',
            values: data,
        },
        basis: {
            type: 'graph',
        },
        layout: {
            nodes: 'nodes',
            links: 'links',
        },
    };
    // Fisrt, decide the layout type and options
    var layoutTypes = graph2LayoutTypes(dataProps);
    // Then, optimize configurations for each layout
    layoutTypes.forEach(function (layoutType) {
        var type = layoutType.type, score = layoutType.score;
        var layoutOptions = optimizeByRule(dataProps, 'pred-layout-config');
        var layout = {
            type: type,
            options: layoutOptions === null || layoutOptions === void 0 ? void 0 : layoutOptions.options,
        };
        var links = edgeFields2Style(__assign(__assign({}, dataProps), { layoutType: type }), options);
        var nodes = nodeFields2Style(__assign(__assign({}, dataProps), { layoutType: type }), options);
        var spec = {
            layout: layout,
            layer: [
                {
                    nodes: nodes,
                    links: links,
                },
            ],
        };
        recommendSpecs.push({ type: 'graph', spec: deepMix(spec, basics), score: score });
    });
    return recommendSpecs;
}
