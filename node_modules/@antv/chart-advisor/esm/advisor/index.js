import { __assign } from "tslib";
import { CKBJson } from '@antv/ckb';
import { DataFrame, GraphData } from '@antv/data-wizard';
import { processRuleCfg } from '../ruler';
import { cloneDeep, deepMix } from './utils';
import { dataToAdvices } from './advice-pipeline/data-to-advices';
import { graphdataToAdvices } from './advice-pipeline/graph-to-advices';
var Advisor = /** @class */ (function () {
    /**
     *
     * @param configuration for Advisor, including
     *
     * - ckbCfg: ckb configuration: `include`, `exclude`, `custom`.
     *  if not specified, used `@antv/ckb` as default
     * - ruleCfg: rule base configuration: `include`, `exclude`, `custom`, `options`.
     *  if not specified, used `ruler` as default
     */
    function Advisor(config) {
        if (config === void 0) { config = {}; }
        Object.assign(this, config);
        var ckb = {};
        if (this.ckbCfg) {
            ckb = this.processCKBCfg(this.ckbCfg);
        }
        this.CKB = this.ckbCfg ? ckb : CKBJson('en-US', true);
        this.ruleBase = processRuleCfg(this.ruleCfg);
    }
    /**
     * chart advising from input data
     * @param params paramters for advising
     */
    Advisor.prototype.advise = function (params) {
        var data = params.data, options = params.options;
        var adviceResult;
        var graphAdvices = this.advicesForGraph(params);
        if (this.shouldRecommendGraph(data, options)) {
            adviceResult = graphAdvices;
            // todo
            // advices = graphAdvices.concat(chartAdvices)
        }
        else {
            var chartAdvices = this.advicesForChart(params);
            // Otherwise, higher priority for statistical charts
            adviceResult = chartAdvices.concat(graphAdvices);
        }
        return adviceResult;
    };
    /**
     * Advise and return with scoring log.
     *
     * @param params
     * @returns
     */
    Advisor.prototype.adviseWithLog = function (params) {
        var data = params.data, options = params.options;
        var adviceResult;
        var graphAdvices = this.advicesForGraph(params);
        if (this.shouldRecommendGraph(data, options)) {
            adviceResult = { advices: graphAdvices, log: [] };
        }
        else {
            var chartAdvices = this.advicesForChart(params, true);
            // with log
            var _a = chartAdvices, advices = _a.advices, log = _a.log;
            var advicesWithGraph = advices.concat(graphAdvices);
            adviceResult = { advices: advicesWithGraph, log: log };
        }
        return adviceResult;
    };
    Advisor.prototype.advicesForChart = function (params, exportLog) {
        if (exportLog === void 0) { exportLog = false; }
        var data = params.data, dataProps = params.dataProps, smartColor = params.smartColor, options = params.options, colorOptions = params.colorOptions;
        // otherwise the input data will be mutated
        var copyData = cloneDeep(data);
        var _a = params, fields = _a.fields, fieldTypes = _a.fieldTypes;
        // transform data into DataFrame
        var dataFrame;
        try {
            if (fields) {
                dataFrame = new DataFrame(copyData, { columns: fields, columnTypes: fieldTypes });
            }
            else {
                dataFrame = new DataFrame(copyData);
            }
        }
        catch (error) {
            // if the input data cannot be transformed into DataFrame
            // eslint-disable-next-line no-console
            console.error('error: ', error);
            return [];
        }
        // get dataProps from dataframe
        var dataPropsForAdvice;
        if (dataProps) {
            // filter out fields that are not included for advising
            dataPropsForAdvice = fields
                ? dataProps.filter(function (dataProp) { return fields.includes(dataProp.name); })
                : dataProps;
        }
        else {
            dataPropsForAdvice = dataFrame.info();
        }
        // filter out fields that are not included for advising
        var filteredData = [];
        if (fields) {
            filteredData = copyData.map(function (row) {
                var filteredRow = row;
                Object.keys(filteredRow).forEach(function (col) {
                    if (!fields.includes(col)) {
                        delete filteredRow[col];
                    }
                });
                return row;
            });
        }
        else {
            filteredData = copyData;
        }
        var adviceResult = dataToAdvices(filteredData, dataPropsForAdvice, this.CKB, this.ruleBase, smartColor, __assign(__assign({}, options), { exportLog: exportLog }), colorOptions);
        return adviceResult;
    };
    // TODO: export log for graph
    Advisor.prototype.advicesForGraph = function (params) {
        var _a;
        var data = params.data, dataProps = params.dataProps, options = params.options;
        var copyData = cloneDeep(data);
        var graphData;
        try {
            graphData = new GraphData(copyData, (_a = options) === null || _a === void 0 ? void 0 : _a.extra);
        }
        catch (error) {
            // if the input data cannot be transformed into DataFrame
            return [];
        }
        var calcedProps = graphData === null || graphData === void 0 ? void 0 : graphData.info();
        var graphDataProps = dataProps ? deepMix(calcedProps, dataProps) : calcedProps;
        var advicesForGraph = graphdataToAdvices(graphData.data, graphDataProps, options);
        return advicesForGraph;
    };
    /**
     * If shouldRecommendGraph is true, higher priority for relational graph
     * @param data
     * @param options
     * @returns
     */
    Advisor.prototype.shouldRecommendGraph = function (data, options) {
        var _a;
        var purposeForGraphs = ['Relation', 'Hierarchy', 'Flow'];
        var keyForGraph = ['nodes', 'edges', 'links', 'from', 'to', 'children'];
        var hasKeyForGraph = Object.prototype.toString.call(data) === '[object Object]' &&
            Object.keys(data).some(function (key) { return keyForGraph.includes(key); });
        return (!!((_a = options) === null || _a === void 0 ? void 0 : _a.extra) ||
            purposeForGraphs.includes(options === null || options === void 0 ? void 0 : options.purpose) ||
            hasKeyForGraph);
    };
    /**
     * processing ckb config and setup ckb used for advising
     * @param ckbCfg input ckb configuration
     * @returns ckb: Record<string, ChartKnowledgeJSON>
     */
    Advisor.prototype.processCKBCfg = function (ckbCfg) {
        // step 1: exclude charts from default CKB
        var ckbBase = CKBJson('en-US', true);
        var toExclude = ckbCfg.exclude;
        if (toExclude) {
            toExclude.forEach(function (chartType) {
                if (Object.keys(ckbBase).includes(chartType)) {
                    delete ckbBase[chartType];
                }
            });
        }
        // step 2: only include charts from default CKB after excluded
        if (ckbCfg.include) {
            var toIncluded_1 = ckbCfg.include;
            Object.keys(ckbBase).forEach(function (chartType) {
                if (!toIncluded_1.includes(chartType)) {
                    delete ckbBase[chartType];
                }
            });
        }
        // step 3: combine default charts and customized charts
        var finalCkbBase = __assign(__assign({}, ckbBase), ckbCfg.custom);
        return finalCkbBase;
    };
    return Advisor;
}());
export { Advisor };
export * from './advice-pipeline';
export * from './ckb-config';
